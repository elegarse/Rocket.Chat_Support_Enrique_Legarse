{"version":3,"file":"index.umd.js","sources":["../src/sheet.ts","../src/transpile/index.ts","../src/names.ts","../src/memoize.ts","../src/tags.ts","../src/cssSupports.ts","../src/transpile/logicalProperties.ts"],"sourcesContent":["import hash from '@emotion/hash';\n\nconst elementId = 'rcx-styles';\nlet element: HTMLStyleElement;\nconst getStyleTag = (): HTMLStyleElement => {\n  if (!element) {\n    element = (document.getElementById(elementId) || document.createElement('style')) as HTMLStyleElement;\n    element.id = elementId;\n    element.appendChild(document.createTextNode(''));\n    if (document.head) {\n      document.head.appendChild(element);\n    }\n  }\n\n  return element;\n};\n\nlet styleSheet: CSSStyleSheet;\nconst getStyleSheet = (): CSSStyleSheet => {\n  if (!styleSheet) {\n    const styleTag = getStyleTag();\n    const _styleSheet = styleTag.sheet || Array.from(document.styleSheets).find(({ ownerNode }) => ownerNode === styleTag);\n\n    if (!_styleSheet) {\n      throw Error('could not get style sheet');\n    }\n\n    styleSheet = _styleSheet;\n  }\n\n  return styleSheet;\n};\n\ntype RuleAttacher = (rules: string) => () => void;\n\nconst discardRules: RuleAttacher = () => () => undefined;\n\nconst attachRulesIntoElement: RuleAttacher = (rules) => {\n  const element = getStyleTag();\n\n  const textNode = document.createTextNode(rules);\n  element.appendChild(textNode);\n\n  return () => textNode.remove();\n};\n\nconst attachRulesIntoStyleSheet: RuleAttacher = (rules) => {\n  const styleSheet = getStyleSheet();\n  const index = styleSheet.insertRule(`@media all{${ rules }}`, styleSheet.cssRules.length);\n  const insertedRule = styleSheet.cssRules[index];\n\n  return () => {\n    const index = Array.prototype.findIndex.call(\n      styleSheet.cssRules,\n      (cssRule: CSSRule): boolean => cssRule === insertedRule,\n    );\n    styleSheet.deleteRule(index);\n  };\n};\n\nconst wrapReferenceCounting = (attacher: RuleAttacher): RuleAttacher => {\n  const refs = {};\n\n  const queueMicrotask = (fn: () => void): void => {\n    if (typeof window === 'undefined' || typeof window.queueMicrotask !== 'function') {\n      Promise.resolve().then(fn);\n      return;\n    }\n\n    window.queueMicrotask(fn);\n  };\n\n  const enhancedAttacher: RuleAttacher = (content: string) => {\n    const id = hash(content);\n\n    if (!refs[id]) {\n      const detach = attacher(content);\n      let count = 0;\n\n      const ref = (): void => {\n        ++count;\n      };\n\n      const unref = (): void => {\n        queueMicrotask(() => {\n          --count;\n          if (count === 0) {\n            detach();\n            delete refs[id];\n          }\n        });\n      };\n\n      refs[id] = {\n        ref,\n        unref,\n      };\n    }\n\n    refs[id].ref();\n    return refs[id].unref;\n  };\n\n  return enhancedAttacher;\n};\n\n/**\n * Imediately attaches CSS rules into the style sheet.\n *\n * @returns a callback to detach the rules\n */\nexport const attachRules: RuleAttacher = (\n  (typeof window === 'undefined' && discardRules)\n  || (\n    process.env.NODE_ENV === 'production'\n    && !!CSSStyleSheet.prototype.insertRule\n    && wrapReferenceCounting(attachRulesIntoStyleSheet)\n  )\n  || wrapReferenceCounting(attachRulesIntoElement)\n);\n","import Stylis, { Options } from '@emotion/stylis';\n\nimport { LogicalPropertiesOptions, createLogicalPropertiesPlugin } from './logicalProperties';\n\ntype TranspileOptions = LogicalPropertiesOptions & Options;\n\nconst createStylis = (options: TranspileOptions): Stylis => {\n  const stylisInstance = new Stylis();\n  stylisInstance.use(createLogicalPropertiesPlugin(options));\n  stylisInstance.set(options);\n\n  return stylisInstance;\n};\n\nlet defaultStylis: Stylis;\n\nconst getDefaultStylis = (): Stylis => {\n  if (!defaultStylis) {\n    defaultStylis = createStylis({});\n  }\n\n  return defaultStylis;\n};\n\n/**\n * Transpiles CSS Modules content to CSS rules.\n */\nexport const transpile = (\n  selector: string,\n  content: string,\n  options?: TranspileOptions,\n): string => {\n  const stylis: Stylis = options ? createStylis(options) : getDefaultStylis();\n  return stylis(selector, content);\n};\n","import hash from '@emotion/hash';\n\nexport const createAnimationName = (content: string): string =>\n  (content ? `rcx-@${ hash(content) }` : 'none');\n\nexport const createClassName = (content: string): string =>\n  `rcx-@${ hash(content) }`;\n\nexport const escapeName = (animationOrClassName: string): string =>\n  animationOrClassName.replace(/@|#|:/g, (char) => `\\\\${ char }`);\n","const store = new WeakMap<(arg: unknown) => unknown, Map<unknown, unknown>>();\n\nexport const memoize = <A, R>(fn: (arg: A) => R): typeof fn => {\n  const cache = new Map<A, R>();\n\n  const memoized: typeof fn = function(this: unknown, arg) {\n    if (cache.has(arg)) {\n      return cache.get(arg);\n    }\n\n    const result = fn.call(this, arg);\n\n    cache.set(arg, result);\n\n    return result;\n  };\n\n  store.set(memoized, cache);\n\n  return memoized;\n};\n\nexport const clear = <A, R>(fn: (arg: A) => R): void => {\n  if (store.has(fn)) {\n    store.get(fn)!.clear();\n  }\n};\n","import { createAnimationName, escapeName } from './names';\nimport { memoize } from './memoize';\n\n/**\n * A shared state created by the upmost Evaluable in the call stack\n */\ntype EvaluationContext = string[];\n\n/**\n * It can be stored at this module scope because all Evaluable calls are\n * synchronous, therefore the first call must create and destroy this context.\n */\nlet currentContext: EvaluationContext | undefined = undefined;\n\n/**\n * Holds to the evaluation context inside a Evaluable.\n *\n * @returns a pair of the evaluation context and a function to free it,\n *          returning the additional evaluation stored at the context.\n */\nexport const holdContext = (): [EvaluationContext, (() => string)] => {\n  if (currentContext) {\n    return [currentContext, () => ''];\n  }\n\n  currentContext = [];\n\n  return [currentContext, () => {\n    const additions = (currentContext || []).join('');\n    currentContext = undefined;\n    return additions;\n  }];\n};\n\n/**\n * A function that lazily evaluates a special string interpolation.\n */\ntype Evaluable = (...args: readonly unknown[]) => string;\n\nconst isEvaluable = (x: unknown): x is Evaluable => typeof x === 'function';\n\nconst staticEvaluable = memoize(\n  <T extends Evaluable>(content: string): T => Object.freeze(() => content) as T,\n);\n\nexport type cssFn = Evaluable;\nexport type keyframesFn = Evaluable;\n\nconst evaluateValue = (value: unknown, args: readonly unknown[]): string => {\n  if (isEvaluable(value) || typeof value === 'function') {\n    return evaluateValue(value(...args), args);\n  }\n\n  if (value === false || value === undefined || value === null) {\n    return '';\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((innerValue) => evaluateValue(innerValue, args)).join('');\n  }\n\n  return String(value);\n};\n\nconst reduceEvaluable = (\n  [first, ...rest]: readonly string[],\n  values: readonly unknown[],\n  args: readonly unknown[],\n): string =>\n  values.reduce<string>(\n    (string, value, i) => string + evaluateValue(value, args) + rest[i],\n    first,\n  ).trim();\n\n/**\n * Template string tag to declare CSS content chunks.\n *\n * @returns a callback to render the CSS content\n */\nexport const css = (slices: TemplateStringsArray, ...values: readonly unknown[]): cssFn => {\n  if (!slices || slices.length === 0 || slices.some((slice) => typeof slice !== 'string')) {\n    return staticEvaluable('');\n  }\n\n  if (!values.some((value) => typeof value === 'function')) {\n    const content = reduceEvaluable(slices, values, []);\n\n    return staticEvaluable(content);\n  }\n\n  return (...args: unknown[]): string => {\n    const [, freeContext] = holdContext();\n\n    const content = reduceEvaluable(slices, values, args);\n\n    return content + freeContext();\n  };\n};\n\n/**\n * Template string tag to declare CSS `@keyframe` at-rules.\n *\n * @returns a callback to render the CSS at-rule content\n */\nexport const keyframes = (slices: TemplateStringsArray, ...values: unknown[]): keyframesFn => {\n  if (!slices || slices.length === 0 || slices.some((slice) => typeof slice !== 'string')) {\n    return staticEvaluable('none');\n  }\n\n  const fn: keyframesFn = (...args: unknown[]): string => {\n    const [context, freeContext] = holdContext();\n\n    const content = reduceEvaluable(slices, values, args);\n\n    const animationName = createAnimationName(content);\n    const escapedAnimationName = escapeName(animationName);\n\n    context.push(`@keyframes ${ escapedAnimationName }{${ content }}`);\n\n    freeContext();\n\n    return escapedAnimationName;\n  };\n\n  return fn;\n};\n","import { memoize } from './memoize';\n\n/**\n * Memoized and SSR-compatible facade of CSS.supports API\n */\nexport const cssSupports: ((value: string) => boolean) = (\n  (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && window.CSS.supports)\n    ? memoize((value: string) => window.CSS.supports(value))\n    : () => false\n);\n","import { Context, Plugin } from '@emotion/stylis';\n\nimport { cssSupports } from '../cssSupports';\n\nexport type LogicalPropertiesOptions = {\n  supportedProperties?: string[];\n};\n\nconst createPropertyName = (...parts: (string | undefined)[]): string => parts.filter(Boolean).join('-');\n\nexport const createLogicalPropertiesPlugin = (options: LogicalPropertiesOptions): Plugin => {\n  const supportedProperties = new Set(options.supportedProperties);\n\n  const isSupported = (property: string): boolean =>\n    supportedProperties.has(property) || cssSupports(`${ property }:inherit`);\n\n  const transforms = new Map<string, (value: string, selectors: string[]) => (string | void)>();\n\n  let buffer = '';\n\n  const replacementTransform = (replacement: string[]) =>\n    (value: string) =>\n      replacement.map((property) => `${ property }:${ value }`).join(';');\n\n  const inlineReplacementTransform = (ltr: string[], rtl: string[]) =>\n    (value: string, selectors: string[]) => {\n      const ltrFn = (value: string): string => ltr.map((property) => `${ property }:${ value }`).join(';');\n      const rtlFn = (value: string): string => rtl.map((property) => `${ property }:${ value }`).join(';');\n\n      buffer += `*:not([dir=rtl]) ${ selectors.join(',') }{${ ltrFn(value) };}`\n        + `[dir=rtl] ${ selectors.join(',') }{${ rtlFn(value) };}`;\n\n      return '';\n    };\n\n  [\n    {\n      base: 'size',\n    },\n    {\n      prefix: 'min',\n      base: 'size',\n    },\n    {\n      prefix: 'max',\n      base: 'size',\n    },\n  ].forEach((property) => {\n    const inline = createPropertyName(property.prefix, 'inline', property.base);\n    const block = createPropertyName(property.prefix, 'block', property.base);\n    const fallbackInline = createPropertyName(property.prefix, 'width');\n    const fallbackBlock = createPropertyName(property.prefix, 'height');\n\n    if (!isSupported(inline)) {\n      transforms.set(inline, replacementTransform([fallbackInline]));\n    }\n\n    if (!isSupported(block)) {\n      transforms.set(block, replacementTransform([fallbackBlock]));\n    }\n  });\n\n  [\n    'clear',\n    'float',\n    'text-align',\n  ].forEach((property) => {\n    const replaceValueTransform = (originalValue: string, ltr: string, rtl: string) =>\n      (value: string, selectors: string[]): string => {\n        buffer += `[dir=rtl] ${ selectors.join(',') }{${ property }: ${ value === originalValue ? rtl : value }}`;\n\n        return `${ property }: ${ value === originalValue ? ltr : value }`;\n      };\n\n    if (!cssSupports(`${ property }: start`)) {\n      transforms.set(property, replaceValueTransform('start', 'left', 'right'));\n    }\n\n    if (!cssSupports(`${ property }: inline-start`)) {\n      transforms.set(property, replaceValueTransform('inline-start', 'left', 'right'));\n    }\n\n    if (!cssSupports(`${ property }: end`)) {\n      transforms.set(property, replaceValueTransform('end', 'right', 'left'));\n    }\n\n    if (!cssSupports(`${ property }: inline-end`)) {\n      transforms.set(property, replaceValueTransform('inline-end', 'right', 'left'));\n    }\n  });\n\n  [\n    {\n      base: 'border',\n      suffix: 'radius',\n      fallbackBase: 'border',\n    },\n  ].forEach((property) => {\n    const startStart = createPropertyName(property.base, 'start-start', property.suffix);\n    const startEnd = createPropertyName(property.base, 'start-end', property.suffix);\n    const endStart = createPropertyName(property.base, 'end-start', property.suffix);\n    const endEnd = createPropertyName(property.base, 'end-end', property.suffix);\n    const fallbackStartStart = createPropertyName(property.base, 'top-left', property.suffix);\n    const fallbackStartEnd = createPropertyName(property.base, 'top-right', property.suffix);\n    const fallbackEndStart = createPropertyName(property.base, 'bottom-left', property.suffix);\n    const fallbackEndEnd = createPropertyName(property.base, 'bottom-right', property.suffix);\n\n    if (!isSupported(startStart)) {\n      transforms.set(startStart, inlineReplacementTransform([fallbackStartStart], [fallbackStartEnd]));\n    }\n\n    if (!isSupported(startEnd)) {\n      transforms.set(startEnd, inlineReplacementTransform([fallbackStartEnd], [fallbackStartStart]));\n    }\n\n    if (!isSupported(endStart)) {\n      transforms.set(endStart, inlineReplacementTransform([fallbackEndStart], [fallbackEndEnd]));\n    }\n\n    if (!isSupported(endEnd)) {\n      transforms.set(endEnd, inlineReplacementTransform([fallbackEndEnd], [fallbackEndStart]));\n    }\n  });\n\n  [\n    {\n      base: 'margin',\n      fallbackBase: 'margin',\n    },\n    {\n      base: 'padding',\n      fallbackBase: 'padding',\n    },\n    {\n      base: 'inset',\n    },\n    {\n      base: 'border',\n      fallbackBase: 'border',\n    },\n    {\n      base: 'border',\n      suffix: 'width',\n      fallbackBase: 'border',\n    },\n    {\n      base: 'border',\n      suffix: 'style',\n      fallbackBase: 'border',\n    },\n    {\n      base: 'border',\n      suffix: 'color',\n      fallbackBase: 'border',\n    },\n  ].forEach((property) => {\n    const all = createPropertyName(property.base, property.suffix);\n    const inline = createPropertyName(property.base, 'inline', property.suffix);\n    const inlineStart = createPropertyName(property.base, 'inline-start', property.suffix);\n    const inlineEnd = createPropertyName(property.base, 'inline-end', property.suffix);\n    const block = createPropertyName(property.base, 'block', property.suffix);\n    const blockStart = createPropertyName(property.base, 'block-start', property.suffix);\n    const blockEnd = createPropertyName(property.base, 'block-end', property.suffix);\n    const fallbackInlineStart = createPropertyName(property.fallbackBase, 'left', property.suffix);\n    const fallbackInlineEnd = createPropertyName(property.fallbackBase, 'right', property.suffix);\n    const fallbackBlockStart = createPropertyName(property.fallbackBase, 'top', property.suffix);\n    const fallbackBlockEnd = createPropertyName(property.fallbackBase, 'bottom', property.suffix);\n\n    const hasInlineStart = isSupported(inlineStart);\n    const hasInlineEnd = isSupported(inlineEnd);\n    const hasBlockStart = isSupported(blockStart);\n    const hasBlockEnd = isSupported(blockEnd);\n    const hasInline = isSupported(inline);\n    const hasBlock = isSupported(block);\n    const hasAll = isSupported(all);\n\n    if (!hasInlineStart) {\n      transforms.set(inlineStart, inlineReplacementTransform([fallbackInlineStart], [fallbackInlineEnd]));\n    }\n\n    if (!hasInlineEnd) {\n      transforms.set(inlineEnd, inlineReplacementTransform([fallbackInlineEnd], [fallbackInlineStart]));\n    }\n\n    if (!hasBlockStart) {\n      transforms.set(blockStart, replacementTransform([fallbackBlockStart]));\n    }\n\n    if (!hasBlockEnd) {\n      transforms.set(blockEnd, replacementTransform([fallbackBlockEnd]));\n    }\n\n    if (!hasInline) {\n      if (hasInlineStart && hasInlineEnd) {\n        transforms.set(inline, replacementTransform([inlineStart, inlineEnd]));\n      } else {\n        transforms.set(inline, inlineReplacementTransform([fallbackInlineStart, fallbackInlineEnd], [fallbackInlineEnd, fallbackInlineStart]));\n      }\n    }\n\n    if (!hasBlock) {\n      if (hasBlockStart && hasBlockEnd) {\n        transforms.set(block, replacementTransform([blockStart, blockEnd]));\n      } else {\n        transforms.set(block, replacementTransform([fallbackBlockStart, fallbackBlockEnd]));\n      }\n    }\n\n    if (!hasAll) {\n      if (hasInline && hasBlock) {\n        transforms.set(all, replacementTransform([inline, block]));\n      } else if (hasInlineStart && hasInlineEnd && hasBlockStart && hasBlockEnd) {\n        transforms.set(all, replacementTransform([inlineStart, inlineEnd, blockStart, blockEnd]));\n      } else {\n        transforms.set(all, inlineReplacementTransform(\n          [fallbackInlineStart, fallbackBlockStart, fallbackInlineEnd, fallbackBlockEnd],\n          [fallbackInlineEnd, fallbackBlockStart, fallbackInlineStart, fallbackBlockEnd],\n        ));\n      }\n    }\n  });\n\n  return (context: Context, content: string, selectors: string[]) => {\n    switch (context) {\n      case -2: {\n        try {\n          return `${ content }${ buffer }`;\n        } finally {\n          buffer = '';\n        }\n      }\n\n      case 1: {\n        let i: number;\n        const property = content.slice(0, i = content.indexOf(':'));\n        const transform = transforms.get(property);\n\n        if (!transform) {\n          return;\n        }\n\n        const value = content.slice(i + 1);\n        const replacement = transform(value, selectors);\n\n        return replacement;\n      }\n    }\n  };\n};\n"],"names":["element","styleSheet","defaultStylis","createAnimationName","content","hash","escapeName","animationOrClassName","replace","char","store","WeakMap","memoize","fn","cache","Map","memoized","arg","has","get","result","call","this","set","currentContext","undefined","holdContext","additions","join","staticEvaluable","Object","freeze","reduceEvaluable","values","args","first","rest","reduce","string","value","i","evaluateValue","Array","isArray","map","innerValue","String","trim","cssSupports","window","CSS","supports","getStyleTag","document","getElementById","createElement","id","appendChild","createTextNode","head","getStyleSheet","styleTag","_styleSheet","sheet","from","styleSheets","find","ownerNode","Error","wrapReferenceCounting","attacher","refs","detach","count","ref","unref","queueMicrotask","Promise","resolve","then","attachRules","process","env","NODE_ENV","CSSStyleSheet","prototype","insertRule","rules","index","cssRules","length","insertedRule","findIndex","cssRule","deleteRule","textNode","remove","createPropertyName","filter","Boolean","createStylis","options","stylisInstance","Stylis","use","supportedProperties","Set","isSupported","property","transforms","buffer","replacementTransform","replacement","inlineReplacementTransform","ltr","rtl","selectors","ltrFn","rtlFn","base","prefix","forEach","inline","block","fallbackInline","fallbackBlock","replaceValueTransform","originalValue","suffix","fallbackBase","startStart","startEnd","endStart","endEnd","fallbackStartStart","fallbackStartEnd","fallbackEndStart","fallbackEndEnd","all","inlineStart","inlineEnd","blockStart","blockEnd","fallbackInlineStart","fallbackInlineEnd","fallbackBlockStart","fallbackBlockEnd","hasInlineStart","hasInlineEnd","hasBlockStart","hasBlockEnd","hasInline","hasBlock","hasAll","context","slice","indexOf","transform","createLogicalPropertiesPlugin","slices","some","freeContext","animationName","escapedAnimationName","push","selector"],"mappings":"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"}