{"version":3,"file":"index.modern.js","sources":["../src/names.ts","../src/memoize.ts","../src/tags.ts","../src/cssSupports.ts","../src/sheet.ts","../src/transpile/logicalProperties.ts","../src/transpile/index.ts"],"sourcesContent":["import hash from '@emotion/hash';\n\nexport const createAnimationName = (content: string): string =>\n  (content ? `rcx-@${ hash(content) }` : 'none');\n\nexport const createClassName = (content: string): string =>\n  `rcx-@${ hash(content) }`;\n\nexport const escapeName = (animationOrClassName: string): string =>\n  animationOrClassName.replace(/@|#|:/g, (char) => `\\\\${ char }`);\n","const store = new WeakMap<(arg: unknown) => unknown, Map<unknown, unknown>>();\n\nexport const memoize = <A, R>(fn: (arg: A) => R): typeof fn => {\n  const cache = new Map<A, R>();\n\n  const memoized: typeof fn = function(this: unknown, arg) {\n    if (cache.has(arg)) {\n      return cache.get(arg);\n    }\n\n    const result = fn.call(this, arg);\n\n    cache.set(arg, result);\n\n    return result;\n  };\n\n  store.set(memoized, cache);\n\n  return memoized;\n};\n\nexport const clear = <A, R>(fn: (arg: A) => R): void => {\n  if (store.has(fn)) {\n    store.get(fn)!.clear();\n  }\n};\n","import { createAnimationName, escapeName } from './names';\nimport { memoize } from './memoize';\n\n/**\n * A shared state created by the upmost Evaluable in the call stack\n */\ntype EvaluationContext = string[];\n\n/**\n * It can be stored at this module scope because all Evaluable calls are\n * synchronous, therefore the first call must create and destroy this context.\n */\nlet currentContext: EvaluationContext | undefined = undefined;\n\n/**\n * Holds to the evaluation context inside a Evaluable.\n *\n * @returns a pair of the evaluation context and a function to free it,\n *          returning the additional evaluation stored at the context.\n */\nexport const holdContext = (): [EvaluationContext, (() => string)] => {\n  if (currentContext) {\n    return [currentContext, () => ''];\n  }\n\n  currentContext = [];\n\n  return [currentContext, () => {\n    const additions = (currentContext || []).join('');\n    currentContext = undefined;\n    return additions;\n  }];\n};\n\n/**\n * A function that lazily evaluates a special string interpolation.\n */\ntype Evaluable = (...args: readonly unknown[]) => string;\n\nconst isEvaluable = (x: unknown): x is Evaluable => typeof x === 'function';\n\nconst staticEvaluable = memoize(\n  <T extends Evaluable>(content: string): T => Object.freeze(() => content) as T,\n);\n\nexport type cssFn = Evaluable;\nexport type keyframesFn = Evaluable;\n\nconst evaluateValue = (value: unknown, args: readonly unknown[]): string => {\n  if (isEvaluable(value) || typeof value === 'function') {\n    return evaluateValue(value(...args), args);\n  }\n\n  if (value === false || value === undefined || value === null) {\n    return '';\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((innerValue) => evaluateValue(innerValue, args)).join('');\n  }\n\n  return String(value);\n};\n\nconst reduceEvaluable = (\n  [first, ...rest]: readonly string[],\n  values: readonly unknown[],\n  args: readonly unknown[],\n): string =>\n  values.reduce<string>(\n    (string, value, i) => string + evaluateValue(value, args) + rest[i],\n    first,\n  ).trim();\n\n/**\n * Template string tag to declare CSS content chunks.\n *\n * @returns a callback to render the CSS content\n */\nexport const css = (slices: TemplateStringsArray, ...values: readonly unknown[]): cssFn => {\n  if (!slices || slices.length === 0 || slices.some((slice) => typeof slice !== 'string')) {\n    return staticEvaluable('');\n  }\n\n  if (!values.some((value) => typeof value === 'function')) {\n    const content = reduceEvaluable(slices, values, []);\n\n    return staticEvaluable(content);\n  }\n\n  return (...args: unknown[]): string => {\n    const [, freeContext] = holdContext();\n\n    const content = reduceEvaluable(slices, values, args);\n\n    return content + freeContext();\n  };\n};\n\n/**\n * Template string tag to declare CSS `@keyframe` at-rules.\n *\n * @returns a callback to render the CSS at-rule content\n */\nexport const keyframes = (slices: TemplateStringsArray, ...values: unknown[]): keyframesFn => {\n  if (!slices || slices.length === 0 || slices.some((slice) => typeof slice !== 'string')) {\n    return staticEvaluable('none');\n  }\n\n  const fn: keyframesFn = (...args: unknown[]): string => {\n    const [context, freeContext] = holdContext();\n\n    const content = reduceEvaluable(slices, values, args);\n\n    const animationName = createAnimationName(content);\n    const escapedAnimationName = escapeName(animationName);\n\n    context.push(`@keyframes ${ escapedAnimationName }{${ content }}`);\n\n    freeContext();\n\n    return escapedAnimationName;\n  };\n\n  return fn;\n};\n","import { memoize } from './memoize';\n\n/**\n * Memoized and SSR-compatible facade of CSS.supports API\n */\nexport const cssSupports: ((value: string) => boolean) = (\n  (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && window.CSS.supports)\n    ? memoize((value: string) => window.CSS.supports(value))\n    : () => false\n);\n","import hash from '@emotion/hash';\n\nconst elementId = 'rcx-styles';\nlet element: HTMLStyleElement;\nconst getStyleTag = (): HTMLStyleElement => {\n  if (!element) {\n    element = (document.getElementById(elementId) || document.createElement('style')) as HTMLStyleElement;\n    element.id = elementId;\n    element.appendChild(document.createTextNode(''));\n    if (document.head) {\n      document.head.appendChild(element);\n    }\n  }\n\n  return element;\n};\n\nlet styleSheet: CSSStyleSheet;\nconst getStyleSheet = (): CSSStyleSheet => {\n  if (!styleSheet) {\n    const styleTag = getStyleTag();\n    const _styleSheet = styleTag.sheet || Array.from(document.styleSheets).find(({ ownerNode }) => ownerNode === styleTag);\n\n    if (!_styleSheet) {\n      throw Error('could not get style sheet');\n    }\n\n    styleSheet = _styleSheet;\n  }\n\n  return styleSheet;\n};\n\ntype RuleAttacher = (rules: string) => () => void;\n\nconst discardRules: RuleAttacher = () => () => undefined;\n\nconst attachRulesIntoElement: RuleAttacher = (rules) => {\n  const element = getStyleTag();\n\n  const textNode = document.createTextNode(rules);\n  element.appendChild(textNode);\n\n  return () => textNode.remove();\n};\n\nconst attachRulesIntoStyleSheet: RuleAttacher = (rules) => {\n  const styleSheet = getStyleSheet();\n  const index = styleSheet.insertRule(`@media all{${ rules }}`, styleSheet.cssRules.length);\n  const insertedRule = styleSheet.cssRules[index];\n\n  return () => {\n    const index = Array.prototype.findIndex.call(\n      styleSheet.cssRules,\n      (cssRule: CSSRule): boolean => cssRule === insertedRule,\n    );\n    styleSheet.deleteRule(index);\n  };\n};\n\nconst wrapReferenceCounting = (attacher: RuleAttacher): RuleAttacher => {\n  const refs = {};\n\n  const queueMicrotask = (fn: () => void): void => {\n    if (typeof window === 'undefined' || typeof window.queueMicrotask !== 'function') {\n      Promise.resolve().then(fn);\n      return;\n    }\n\n    window.queueMicrotask(fn);\n  };\n\n  const enhancedAttacher: RuleAttacher = (content: string) => {\n    const id = hash(content);\n\n    if (!refs[id]) {\n      const detach = attacher(content);\n      let count = 0;\n\n      const ref = (): void => {\n        ++count;\n      };\n\n      const unref = (): void => {\n        queueMicrotask(() => {\n          --count;\n          if (count === 0) {\n            detach();\n            delete refs[id];\n          }\n        });\n      };\n\n      refs[id] = {\n        ref,\n        unref,\n      };\n    }\n\n    refs[id].ref();\n    return refs[id].unref;\n  };\n\n  return enhancedAttacher;\n};\n\n/**\n * Imediately attaches CSS rules into the style sheet.\n *\n * @returns a callback to detach the rules\n */\nexport const attachRules: RuleAttacher = (\n  (typeof window === 'undefined' && discardRules)\n  || (\n    process.env.NODE_ENV === 'production'\n    && !!CSSStyleSheet.prototype.insertRule\n    && wrapReferenceCounting(attachRulesIntoStyleSheet)\n  )\n  || wrapReferenceCounting(attachRulesIntoElement)\n);\n","import { Context, Plugin } from '@emotion/stylis';\n\nimport { cssSupports } from '../cssSupports';\n\nexport type LogicalPropertiesOptions = {\n  supportedProperties?: string[];\n};\n\nconst createPropertyName = (...parts: (string | undefined)[]): string => parts.filter(Boolean).join('-');\n\nexport const createLogicalPropertiesPlugin = (options: LogicalPropertiesOptions): Plugin => {\n  const supportedProperties = new Set(options.supportedProperties);\n\n  const isSupported = (property: string): boolean =>\n    supportedProperties.has(property) || cssSupports(`${ property }:inherit`);\n\n  const transforms = new Map<string, (value: string, selectors: string[]) => (string | void)>();\n\n  let buffer = '';\n\n  const replacementTransform = (replacement: string[]) =>\n    (value: string) =>\n      replacement.map((property) => `${ property }:${ value }`).join(';');\n\n  const inlineReplacementTransform = (ltr: string[], rtl: string[]) =>\n    (value: string, selectors: string[]) => {\n      const ltrFn = (value: string): string => ltr.map((property) => `${ property }:${ value }`).join(';');\n      const rtlFn = (value: string): string => rtl.map((property) => `${ property }:${ value }`).join(';');\n\n      buffer += `*:not([dir=rtl]) ${ selectors.join(',') }{${ ltrFn(value) };}`\n        + `[dir=rtl] ${ selectors.join(',') }{${ rtlFn(value) };}`;\n\n      return '';\n    };\n\n  [\n    {\n      base: 'size',\n    },\n    {\n      prefix: 'min',\n      base: 'size',\n    },\n    {\n      prefix: 'max',\n      base: 'size',\n    },\n  ].forEach((property) => {\n    const inline = createPropertyName(property.prefix, 'inline', property.base);\n    const block = createPropertyName(property.prefix, 'block', property.base);\n    const fallbackInline = createPropertyName(property.prefix, 'width');\n    const fallbackBlock = createPropertyName(property.prefix, 'height');\n\n    if (!isSupported(inline)) {\n      transforms.set(inline, replacementTransform([fallbackInline]));\n    }\n\n    if (!isSupported(block)) {\n      transforms.set(block, replacementTransform([fallbackBlock]));\n    }\n  });\n\n  [\n    'clear',\n    'float',\n    'text-align',\n  ].forEach((property) => {\n    const replaceValueTransform = (originalValue: string, ltr: string, rtl: string) =>\n      (value: string, selectors: string[]): string => {\n        buffer += `[dir=rtl] ${ selectors.join(',') }{${ property }: ${ value === originalValue ? rtl : value }}`;\n\n        return `${ property }: ${ value === originalValue ? ltr : value }`;\n      };\n\n    if (!cssSupports(`${ property }: start`)) {\n      transforms.set(property, replaceValueTransform('start', 'left', 'right'));\n    }\n\n    if (!cssSupports(`${ property }: inline-start`)) {\n      transforms.set(property, replaceValueTransform('inline-start', 'left', 'right'));\n    }\n\n    if (!cssSupports(`${ property }: end`)) {\n      transforms.set(property, replaceValueTransform('end', 'right', 'left'));\n    }\n\n    if (!cssSupports(`${ property }: inline-end`)) {\n      transforms.set(property, replaceValueTransform('inline-end', 'right', 'left'));\n    }\n  });\n\n  [\n    {\n      base: 'border',\n      suffix: 'radius',\n      fallbackBase: 'border',\n    },\n  ].forEach((property) => {\n    const startStart = createPropertyName(property.base, 'start-start', property.suffix);\n    const startEnd = createPropertyName(property.base, 'start-end', property.suffix);\n    const endStart = createPropertyName(property.base, 'end-start', property.suffix);\n    const endEnd = createPropertyName(property.base, 'end-end', property.suffix);\n    const fallbackStartStart = createPropertyName(property.base, 'top-left', property.suffix);\n    const fallbackStartEnd = createPropertyName(property.base, 'top-right', property.suffix);\n    const fallbackEndStart = createPropertyName(property.base, 'bottom-left', property.suffix);\n    const fallbackEndEnd = createPropertyName(property.base, 'bottom-right', property.suffix);\n\n    if (!isSupported(startStart)) {\n      transforms.set(startStart, inlineReplacementTransform([fallbackStartStart], [fallbackStartEnd]));\n    }\n\n    if (!isSupported(startEnd)) {\n      transforms.set(startEnd, inlineReplacementTransform([fallbackStartEnd], [fallbackStartStart]));\n    }\n\n    if (!isSupported(endStart)) {\n      transforms.set(endStart, inlineReplacementTransform([fallbackEndStart], [fallbackEndEnd]));\n    }\n\n    if (!isSupported(endEnd)) {\n      transforms.set(endEnd, inlineReplacementTransform([fallbackEndEnd], [fallbackEndStart]));\n    }\n  });\n\n  [\n    {\n      base: 'margin',\n      fallbackBase: 'margin',\n    },\n    {\n      base: 'padding',\n      fallbackBase: 'padding',\n    },\n    {\n      base: 'inset',\n    },\n    {\n      base: 'border',\n      fallbackBase: 'border',\n    },\n    {\n      base: 'border',\n      suffix: 'width',\n      fallbackBase: 'border',\n    },\n    {\n      base: 'border',\n      suffix: 'style',\n      fallbackBase: 'border',\n    },\n    {\n      base: 'border',\n      suffix: 'color',\n      fallbackBase: 'border',\n    },\n  ].forEach((property) => {\n    const all = createPropertyName(property.base, property.suffix);\n    const inline = createPropertyName(property.base, 'inline', property.suffix);\n    const inlineStart = createPropertyName(property.base, 'inline-start', property.suffix);\n    const inlineEnd = createPropertyName(property.base, 'inline-end', property.suffix);\n    const block = createPropertyName(property.base, 'block', property.suffix);\n    const blockStart = createPropertyName(property.base, 'block-start', property.suffix);\n    const blockEnd = createPropertyName(property.base, 'block-end', property.suffix);\n    const fallbackInlineStart = createPropertyName(property.fallbackBase, 'left', property.suffix);\n    const fallbackInlineEnd = createPropertyName(property.fallbackBase, 'right', property.suffix);\n    const fallbackBlockStart = createPropertyName(property.fallbackBase, 'top', property.suffix);\n    const fallbackBlockEnd = createPropertyName(property.fallbackBase, 'bottom', property.suffix);\n\n    const hasInlineStart = isSupported(inlineStart);\n    const hasInlineEnd = isSupported(inlineEnd);\n    const hasBlockStart = isSupported(blockStart);\n    const hasBlockEnd = isSupported(blockEnd);\n    const hasInline = isSupported(inline);\n    const hasBlock = isSupported(block);\n    const hasAll = isSupported(all);\n\n    if (!hasInlineStart) {\n      transforms.set(inlineStart, inlineReplacementTransform([fallbackInlineStart], [fallbackInlineEnd]));\n    }\n\n    if (!hasInlineEnd) {\n      transforms.set(inlineEnd, inlineReplacementTransform([fallbackInlineEnd], [fallbackInlineStart]));\n    }\n\n    if (!hasBlockStart) {\n      transforms.set(blockStart, replacementTransform([fallbackBlockStart]));\n    }\n\n    if (!hasBlockEnd) {\n      transforms.set(blockEnd, replacementTransform([fallbackBlockEnd]));\n    }\n\n    if (!hasInline) {\n      if (hasInlineStart && hasInlineEnd) {\n        transforms.set(inline, replacementTransform([inlineStart, inlineEnd]));\n      } else {\n        transforms.set(inline, inlineReplacementTransform([fallbackInlineStart, fallbackInlineEnd], [fallbackInlineEnd, fallbackInlineStart]));\n      }\n    }\n\n    if (!hasBlock) {\n      if (hasBlockStart && hasBlockEnd) {\n        transforms.set(block, replacementTransform([blockStart, blockEnd]));\n      } else {\n        transforms.set(block, replacementTransform([fallbackBlockStart, fallbackBlockEnd]));\n      }\n    }\n\n    if (!hasAll) {\n      if (hasInline && hasBlock) {\n        transforms.set(all, replacementTransform([inline, block]));\n      } else if (hasInlineStart && hasInlineEnd && hasBlockStart && hasBlockEnd) {\n        transforms.set(all, replacementTransform([inlineStart, inlineEnd, blockStart, blockEnd]));\n      } else {\n        transforms.set(all, inlineReplacementTransform(\n          [fallbackInlineStart, fallbackBlockStart, fallbackInlineEnd, fallbackBlockEnd],\n          [fallbackInlineEnd, fallbackBlockStart, fallbackInlineStart, fallbackBlockEnd],\n        ));\n      }\n    }\n  });\n\n  return (context: Context, content: string, selectors: string[]) => {\n    switch (context) {\n      case -2: {\n        try {\n          return `${ content }${ buffer }`;\n        } finally {\n          buffer = '';\n        }\n      }\n\n      case 1: {\n        let i: number;\n        const property = content.slice(0, i = content.indexOf(':'));\n        const transform = transforms.get(property);\n\n        if (!transform) {\n          return;\n        }\n\n        const value = content.slice(i + 1);\n        const replacement = transform(value, selectors);\n\n        return replacement;\n      }\n    }\n  };\n};\n","import Stylis, { Options } from '@emotion/stylis';\n\nimport { LogicalPropertiesOptions, createLogicalPropertiesPlugin } from './logicalProperties';\n\ntype TranspileOptions = LogicalPropertiesOptions & Options;\n\nconst createStylis = (options: TranspileOptions): Stylis => {\n  const stylisInstance = new Stylis();\n  stylisInstance.use(createLogicalPropertiesPlugin(options));\n  stylisInstance.set(options);\n\n  return stylisInstance;\n};\n\nlet defaultStylis: Stylis;\n\nconst getDefaultStylis = (): Stylis => {\n  if (!defaultStylis) {\n    defaultStylis = createStylis({});\n  }\n\n  return defaultStylis;\n};\n\n/**\n * Transpiles CSS Modules content to CSS rules.\n */\nexport const transpile = (\n  selector: string,\n  content: string,\n  options?: TranspileOptions,\n): string => {\n  const stylis: Stylis = options ? createStylis(options) : getDefaultStylis();\n  return stylis(selector, content);\n};\n"],"names":["createAnimationName","content","hash","createClassName","escapeName","animationOrClassName","replace","char","store","WeakMap","memoize","fn","cache","Map","memoized","arg","has","get","result","call","this","set","currentContext","undefined","holdContext","additions","join","staticEvaluable","Object","freeze","evaluateValue","value","args","Array","isArray","map","innerValue","String","reduceEvaluable","first","rest","values","reduce","string","i","trim","css","slices","length","some","slice","freeContext","keyframes","context","animationName","escapedAnimationName","push","cssSupports","window","CSS","supports","element","getStyleTag","document","getElementById","createElement","id","appendChild","createTextNode","head","styleSheet","getStyleSheet","styleTag","_styleSheet","sheet","from","styleSheets","find","ownerNode","Error","wrapReferenceCounting","attacher","refs","detach","count","unref","queueMicrotask","Promise","resolve","then","ref","attachRules","process","env","NODE_ENV","CSSStyleSheet","prototype","insertRule","rules","index","cssRules","insertedRule","findIndex","cssRule","deleteRule","textNode","remove","createPropertyName","parts","filter","Boolean","createStylis","options","stylisInstance","Stylis","use","supportedProperties","Set","isSupported","property","transforms","buffer","replacementTransform","replacement","inlineReplacementTransform","ltr","rtl","selectors","ltrFn","rtlFn","base","prefix","forEach","inline","block","fallbackInline","fallbackBlock","replaceValueTransform","originalValue","suffix","fallbackBase","startStart","startEnd","endStart","endEnd","fallbackStartStart","fallbackStartEnd","fallbackEndStart","fallbackEndEnd","all","inlineStart","inlineEnd","blockStart","blockEnd","fallbackInlineStart","fallbackInlineEnd","fallbackBlockStart","fallbackBlockEnd","hasInlineStart","hasInlineEnd","hasBlockStart","hasBlockEnd","hasInline","hasBlock","hasAll","indexOf","transform","createLogicalPropertiesPlugin","defaultStylis","transpile","selector"],"mappings":"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"}